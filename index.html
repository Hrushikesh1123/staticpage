<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>XML to JSON Converter</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    textarea { width: 100%; }
    button { padding: 10px 20px; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>XML to JSON Converter</h1>
  <p>Paste your XML below:</p>
  <textarea id="xmlInput" rows="15" placeholder="Paste your XML here"></textarea><br>
  <button onclick="process()">Convert</button>
  <h2>JSON Output:</h2>
  <textarea id="jsonOutput" rows="20" readonly placeholder="JSON output will appear here"></textarea>

  <script>
    // Use your provided XSLT content
    const REMOVE_NS_XSLT_CONTENT = `<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="xml" indent="yes" />
  <xsl:template match="*">
      <xsl:element name="{local-name(.)}">
          <xsl:apply-templates select="@* | node()" />
      </xsl:element>
  </xsl:template>
  <xsl:template match="@*">
      <xsl:attribute name="{local-name(.)}">
        <xsl:value-of select="." />
      </xsl:attribute>
  </xsl:template>
</xsl:stylesheet>`;

    function removeXMLNameSpace(xmlData) {
      try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlData, "text/xml");
        const xsltProcessor = new XSLTProcessor();
        const xsltDoc = parser.parseFromString(REMOVE_NS_XSLT_CONTENT, "text/xml");
        xsltProcessor.importStylesheet(xsltDoc);
        const resultDoc = xsltProcessor.transformToDocument(xmlDoc);
        const serializer = new XMLSerializer();
        return serializer.serializeToString(resultDoc);
      } catch (e) {
        console.error(e);
      }
      return xmlData;
    }

    function xmlToJson(node) {
      if (node.nodeType === 3) { // Text node
        const text = node.nodeValue.trim();
        return text ? text : null;
      }
      if (node.nodeType !== 1) return null; // Non-element nodes

      let obj = {};

      // Copy attributes
      if (node.attributes && node.attributes.length > 0) {
        for (let i = 0; i < node.attributes.length; i++) {
          const attr = node.attributes.item(i);
          obj[attr.nodeName] = attr.nodeValue;
        }
      }

      const children = Array.from(node.childNodes).filter(n => 
        (n.nodeType === 1) || (n.nodeType === 3 && n.nodeValue.trim() !== "")
      );

      // If there's only one text child, store it as content
      if (children.length === 1 && children[0].nodeType === 3) {
        obj.content = children[0].nodeValue.trim();
        return obj;
      }

      // Process child elements
      children.forEach(child => {
        if (child.nodeType === 3) return;
        const childName = child.nodeName;
        const childJson = xmlToJson(child);
        if (childJson === null) return;

        if (obj.hasOwnProperty(childName)) {
          if (!Array.isArray(obj[childName])) {
            obj[childName] = [obj[childName]];
          }
          obj[childName].push(childJson);
        } else {
          obj[childName] = childJson;
        }
      });

      return obj;
    }

    function convertXMLToJSONString(xml, removeNameSpace) {
      let newXML = xml;
      if (removeNameSpace) {
        newXML = removeXMLNameSpace(xml);
      }
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(newXML, "text/xml");
      const jsObj = xmlToJson(xmlDoc);
      return JSON.stringify(jsObj, null, 2);
    }

    function process() {
      const xmlInput = document.getElementById("xmlInput").value;
      const jsonOutput = convertXMLToJSONString(xmlInput, true);
      document.getElementById("jsonOutput").value = jsonOutput;
    }
  </script>
</body>
</html>
